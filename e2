local tArgs = { ... }
if #tArgs ~= 1 then
    local programName = arg[0] or fs.getName(shell.getRunningProgram())
    print("Usage: " .. programName .. " <diameter>")
    return
end
-- Mine in a quarry pattern until we hit something we can't dig
local size = tonumber(tArgs[1])
if size < 1 then
    print("Excavate diameter must be positive")
    return
end
function Excavate(size)
    if type(size) ~= "number" or size < 1 then
        error("Excavate diameter must be a positive number")
    end

    local depth = 0
    local unloaded = 0
    local collected = 0

    local xPos, zPos = 0, 0
    local xDir, zDir = 0, 1

    local function unload(_bKeepOneFuelStack)
        print("Unloading items...")
        for n = 1, 16 do
            local nCount = turtle.getItemCount(n)
            if nCount > 0 then
                turtle.select(n)
                local bDrop = true
                if _bKeepOneFuelStack and turtle.refuel(0) then
                    bDrop = false
                    _bKeepOneFuelStack = false
                end
                if bDrop then
                    turtle.drop()
                    unloaded = unloaded + nCount
                end
            end
        end
        collected = 0
        turtle.select(1)
    end

    local function returnSupplies()
        local x, y, z, xd, zd = xPos, depth, zPos, xDir, zDir
        print("Returning to surface...")
        goTo(0, 0, 0, 0, -1)

        local fuelNeeded = 2 * (x + y + z) + 1
        if not refuel(fuelNeeded) then
            unload(true)
            print("Waiting for fuel")
            while not refuel(fuelNeeded) do
                os.pullEvent("turtle_inventory")
            end
        else
            unload(true)
        end

        print("Resuming mining...")
        goTo(x, y, z, xd, zd)
    end

    local function collect()
        local bFull = true
        local nTotalItems = 0
        for n = 1, 16 do
            local nCount = turtle.getItemCount(n)
            if nCount == 0 then
                bFull = false
            end
            nTotalItems = nTotalItems + nCount
        end

        if nTotalItems > collected then
            collected = nTotalItems
            if math.fmod(collected + unloaded, 50) == 0 then
                print("Mined " .. collected + unloaded .. " items.")
            end
        end

        if bFull then
            print("No empty slots left.")
            return false
        end
        return true
    end

    local function refuel(amount)
        local fuelLevel = turtle.getFuelLevel()
        if fuelLevel == "unlimited" then
            return true
        end

        local needed = amount or xPos + zPos + depth + 2
        if turtle.getFuelLevel() < needed then
            for n = 1, 16 do
                if turtle.getItemCount(n) > 0 then
                    turtle.select(n)
                    if turtle.refuel(1) then
                        while turtle.getItemCount(n) > 0 and turtle.getFuelLevel() < needed do
                            turtle.refuel(1)
                        end
                        if turtle.getFuelLevel() >= needed then
                            turtle.select(1)
                            return true
                        end
                    end
                end
            end
            turtle.select(1)
            return false
        end

        return true
    end

    local function tryMove(forwardFn, digFn, attackFn, collectFn, moveFn, axisPos, axisDir, axisDelta)
        if not refuel() then
            print("Not enough Fuel")
            returnSupplies()
        end

        while not forwardFn() do
            if digFn() then
                if not collectFn() then
                    returnSupplies()
                end
            elseif attackFn() then
                if not collectFn() then
                    returnSupplies()
                end
            else
                sleep(0.5)
            end
        end

        axisPos = axisPos + axisDir
        return axisPos, axisDir, axisDelta
    end

    local function turn(directionFn, turnFn, newDirFn, axisDir, xDir, zDir)
        directionFn()
        xDir, zDir = newDirFn(zDir, xDir)
        return xDir, zDir
    end

    local function goTo(x, y, z, xd, zd)
        while depth > y do
            if turtle.up() then
                depth = depth - 1
            elseif turtle.digUp() or turtle.attackUp() then
                collect()
            else
                sleep(0.5)
            end
        end

        if xPos > x then
            while xDir ~= -1 do
                turn(turtle.turnLeft, turtle.forward, function (zDir, xDir) return -zDir, xDir end, zDir, xDir, zDir)
            end
            while xPos > x do
                xPos, xDir, zDir = tryMove(turtle.forward, turtle.dig, turtle.attack, collect, turtle.forward, xPos, xDir, -1)
            end
        elseif xPos < x then
            while xDir ~= 1 do
                turn(turtle.turnLeft, turtle.forward, function (zDir, xDir) return -zDir, xDir end, zDir, xDir, zDir)
            end
            while xPos < x do
                xPos, xDir, zDir = tryMove(turtle.forward, turtle.dig, turtle.attack, collect, turtle.forward, xPos, xDir, 1)
            end
        end

        if zPos > z then
            while zDir ~= -1 do
                turn(turtle.turnLeft, turtle.forward, function (zDir, xDir) return -zDir, xDir end, zDir, xDir, zDir)
            end
            while zPos > z do
                zPos, xDir, zDir = tryMove(turtle.forward, turtle.dig, turtle.attack, collect, turtle.forward, zPos, zDir, -1)
            end
        elseif zPos < z then
            while zDir ~= 1 do
                turn(turtle.turnLeft, turtle.forward, function (zDir, xDir) return -zDir, xDir end, zDir, xDir, zDir)
            end
            while zPos < z do
                zPos, xDir, zDir = tryMove(turtle.forward, turtle.dig, turtle.attack, collect, turtle.forward, zPos, zDir, 1)
            end
        end

        while depth < y do
            if turtle.down() then
                depth = depth + 1
            elseif turtle.digDown() or turtle.attackDown() then
                collect()
            else
                sleep(0.5)
            end
        end

        while zDir ~= zd or xDir ~= xd do
            turn(turtle.turnLeft, turtle.forward, function (zDir, xDir) return -zDir, xDir end, zDir, xDir, zDir)
        end
    end

    if not refuel() then
        print("Out of Fuel")
        return
    end

    print("Excavating...")

    local reseal = false
    turtle.select(1)
    if turtle.digDown() then
        reseal = true
    end

    local alternate = 0
    local done = false
    while not done do
        for n = 1, size do
            for _ = 1, size - 1 do
                if not tryMove(turtle.forward, turtle.dig, turtle.attack, collect, turtle.forward, size, alternate, xDir, zDir) then
                    done = true
                    break
                end
            end
            if done then
                break
            end
            if n < size then
                if math.fmod(n + alternate, 2) == 0 then
                    turn(turtle.turnLeft, turtle.forward, function (zDir, xDir) return -zDir, xDir end, zDir, xDir, zDir)
                    if not tryMove(turtle.forward, turtle.dig, turtle.attack, collect, turtle.forward, size, alternate, xDir, zDir) then
                        done = true
                        break
                    end
                    turn(turtle.turnLeft, turtle.forward, function (zDir, xDir) return -zDir, xDir end, zDir, xDir, zDir)
                else
                    turn(turtle.turnRight, turtle.forward, function (zDir, xDir) return zDir, -xDir end, zDir, xDir, zDir)
                    if not tryMove(turtle.forward, turtle.dig, turtle.attack, collect, turtle.forward, size, alternate, xDir, zDir) then
                        done = true
                        break
                    end
                    turn(turtle.turnRight, turtle.forward, function (zDir, xDir) return zDir, -xDir end, zDir, xDir, zDir)
                end
            end
        end
        if done then
            break
        end

        if size > 1 then
            if math.fmod(size, 2) == 0 then
                turn(turtle.turnRight, turtle.forward, function (zDir, xDir) return zDir, -xDir end, zDir, xDir, zDir)
            else
                if alternate == 0 then
                    turn(turtle.turnLeft, turtle.forward, function (zDir, xDir) return -zDir, xDir end, zDir, xDir, zDir)
                else
                    turn(turtle.turnRight, turtle.forward, function (zDir, xDir) return zDir, -xDir end, zDir, xDir, zDir)
                end
                alternate = 1 - alternate
            end
        end

        if not tryMove(turtle.forward, turtle.dig, turtle.attack, collect, turtle.forward, size, alternate, xDir, zDir) then
            done = true
            break
        end
    end

    print("Returning to surface...")

    -- Return to where we started
    goTo(0, 0, 0, 0, -1)
    unload(false)
    goTo(0, 0, 0, 0, 1)

    -- Seal the hole
    if reseal then
        turtle.placeDown()
    end

    print("Mined " .. collected + unloaded .. " items total.")
end

